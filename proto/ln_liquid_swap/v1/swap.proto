syntax = "proto3";

package ln_liquid_swap.v1;

import "buf/validate/validate.proto";
import "google/api/field_behavior.proto";

// LNâ†’Liquid swap schema.
//
// This API is intentionally gRPC-only (no HTTP JSON transcoding).
//
// Overview:
// - The seller locks a Liquid asset in a P2WSH HTLC (hashlock + CLTV).
// - The seller creates a standard BOLT11 invoice whose payment hash matches the HTLC hashlock.
// - The buyer pays the invoice, obtains the preimage, and claims the Liquid HTLC with:
//   - the preimage, and
//   - the buyer signature (so intermediaries cannot steal with preimage-only).
//
// Notes:
// - This swap provides "practical atomicity", not full atomicity.
// - HTLC outputs are explicit (unblinded) in this minimal design.
service SwapService {
  // Creates a quote for a potential swap.
  //
  // This RPC is used to discover the current price and policy parameters without funding an HTLC.
  //
  // Errors:
  // - `INVALID_ARGUMENT` if the request is malformed or fails validation.
  // - `FAILED_PRECONDITION` if the seller does not support the given asset id.
  rpc CreateQuote(CreateQuoteRequest) returns (Quote);

  // Gets a quote by id.
  //
  // Errors:
  // - `INVALID_ARGUMENT` if `quote_id` is malformed.
  // - `NOT_FOUND` if the quote does not exist.
  rpc GetQuote(GetQuoteRequest) returns (Quote);

  // Creates a new swap from a previously created quote.
  //
  // Server behavior (minimal implementation):
  // - Resolves `quote_id` into a persisted quote.
  // - Rejects if the current offer differs from the quote.
  // - Funds the Liquid HTLC and broadcasts the funding transaction.
  // - Waits until the funding transaction has at least `min_funding_confs` confirmations.
  // - Returns the BOLT11 invoice and the Liquid HTLC details.
  //
  // Errors:
  // - `INVALID_ARGUMENT` if the request is malformed or fails validation.
  // - `NOT_FOUND` if the quote does not exist.
  // - `FAILED_PRECONDITION` if the offer changed since quoting, or if the seller cannot fund.
  // - `INTERNAL` for unexpected wallet / backend failures.
  rpc CreateSwap(CreateSwapRequest) returns (Swap);

  // Gets a swap by id.
  //
  // Errors:
  // - `INVALID_ARGUMENT` if `swap_id` is malformed.
  // - `NOT_FOUND` if the swap does not exist.
  rpc GetSwap(GetSwapRequest) returns (Swap);

  // Pays the Lightning invoice for a swap and returns the payment result.
  //
  // Errors:
  // - `INVALID_ARGUMENT` if the request is malformed or fails validation.
  // - `NOT_FOUND` if the swap does not exist.
  // - `FAILED_PRECONDITION` if the swap is not funded.
  // - `INTERNAL` for unexpected LN backend failures.
  rpc PayLightning(PayLightningRequest) returns (PayLightningResponse);

  // Claims the Liquid HTLC for a swap (asset acquisition).
  //
  // Errors:
  // - `INVALID_ARGUMENT` if the request is malformed or fails validation.
  // - `NOT_FOUND` if the swap does not exist.
  // - `FAILED_PRECONDITION` if the swap has not been paid yet (missing preimage).
  // - `INTERNAL` for unexpected wallet / backend failures.
  rpc ClaimAsset(ClaimAssetRequest) returns (ClaimAssetResponse);
}

message CreateQuoteRequest {
  // The asset id (32 bytes, hex-encoded).
  //
  // Current implementation supports exactly one sellable asset id.
  string asset_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true,
    (buf.validate.field).string.len = 64,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{64}$"
  ];

  // The amount of the asset to receive.
  //
  // Must be greater than 0.
  uint64 asset_amount = 2 [(buf.validate.field).uint64.gt = 0];

  // The minimum required confirmations for the HTLC funding transaction.
  //
  // If this value is 0, the server may return once the funding transaction is visible to the
  // Liquid backend (typically mempool).
  //
  // The server may reject excessively large values to avoid long-running requests.
  uint32 min_funding_confs = 3 [(buf.validate.field).uint32.lte = 6];
}

message Quote {
  // The quote id. Use this value with `GetQuote` and `CreateSwap`.
  string quote_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 64,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
  ];

  // The offer snapshot id (SHA256 hex, 32 bytes).
  //
  // If the seller changes the offer parameters after issuing a quote,
  // `CreateSwap` rejects due to `offer_id` mismatch.
  string offer_id = 2 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true,
    (buf.validate.field).string.len = 64,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{64}$"
  ];

  // The offer snapshot used to compute this quote.
  Offer offer = 3;

  // The Liquid address that will receive the claimed outputs.
  //
  // This design expects a P2WPKH address (v0 witness program, 20 bytes).
  string buyer_claim_address = 4;

  // The asset id being sold (hex-encoded).
  string asset_id = 5;

  // The amount of the asset to receive.
  uint64 asset_amount = 6;

  // The minimum required confirmations for the HTLC funding transaction.
  uint32 min_funding_confs = 7;

  // The total price in millisatoshis.
  uint64 total_price_msat = 8;
}

message GetQuoteRequest {
  // The quote id returned by `CreateQuote`.
  string quote_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 64,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
  ];
}

message CreateSwapRequest {
  // The quote id returned by `CreateQuote`.
  string quote_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 64,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
  ];
}

message Offer {
  // The asset id being sold (hex-encoded).
  string asset_id = 1;

  // The price in millisatoshis per 1 asset unit.
  uint64 price_msat_per_asset_unit = 2;

  // The LBTC amount the seller locks in the HTLC to subsidize claim/refund fees.
  uint64 fee_subsidy_sats = 3;

  // The relative refund timelock in blocks (used to compute `refund_lock_height`).
  uint32 refund_delta_blocks = 4;

  // The invoice expiry used for swaps (seconds).
  uint32 invoice_expiry_secs = 5;

  // The maximum allowed `min_funding_confs` accepted by the server.
  uint32 max_min_funding_confs = 6;
}

message GetSwapRequest {
  // The swap id returned by `CreateSwap`.
  //
  // Current implementation uses a UUID string.
  string swap_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 64,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
  ];
}

message PayLightningRequest {
  // The swap id returned by `CreateSwap`.
  string swap_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 64,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
  ];

  // The maximum time to wait for the preimage after initiating payment (seconds).
  //
  // If this value is 0, the server uses a default.
  uint32 payment_timeout_secs = 2 [(buf.validate.field).uint32.lte = 600];
}

message PayLightningResponse {
  // The payment id returned by the LN backend.
  string payment_id = 1;

  // The preimage obtained after successful payment (32 bytes).
  bytes preimage = 2;
}

message ClaimAssetRequest {
  // The swap id returned by `CreateSwap`.
  string swap_id = 1 [
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.max_len = 64,
    (buf.validate.field).string.pattern = "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
  ];

  // The fee to pay for the claim transaction (sats).
  //
  // If this value is 0, the server uses a default.
  uint64 claim_fee_sats = 2;
}

message ClaimAssetResponse {
  // The txid of the claim transaction (hex-encoded).
  string claim_txid = 1;
}

// SwapStatus describes the server's view of the swap lifecycle.
enum SwapStatus {
  SWAP_STATUS_UNSPECIFIED = 0;
  SWAP_STATUS_CREATED = 1;
  SWAP_STATUS_FUNDED = 2;
  SWAP_STATUS_CLAIMED = 3;
  SWAP_STATUS_REFUNDED = 4;
  SWAP_STATUS_FAILED = 5;
  SWAP_STATUS_PAID = 6;
}

message Swap {
  // The swap id. Use this value with `GetSwap`.
  string swap_id = 1;

  // The Lightning invoice to be paid by the buyer.
  string bolt11_invoice = 2;

  // The invoice payment hash (hex-encoded, 32 bytes).
  string payment_hash = 3;

  // The current swap status.
  SwapStatus status = 4;

  // Liquid-side HTLC details.
  LiquidHtlc liquid = 5;

  // The quote id used to create this swap.
  string quote_id = 6;
}

message LiquidHtlc {
  // The asset id (hex-encoded).
  string asset_id = 1;

  // The locked amount for the asset output.
  uint64 asset_amount = 2;

  // The locked amount for the fee-subsidy LBTC output.
  uint64 fee_subsidy_sats = 3;

  // The absolute refund lock height used in CLTV (block height).
  uint32 refund_lock_height = 4;

  // The P2WSH address of the HTLC output(s).
  string p2wsh_address = 5;

  // The HTLC witness script (raw bytes).
  //
  // Clients may use this value to:
  // - derive the expected P2WSH scriptPubKey, and
  // - verify the embedded payment hash (hashlock) and refund lock height (CLTV).
  bytes witness_script = 6;

  // The txid of the funding transaction (hex-encoded).
  string funding_txid = 7;

  // The vout of the locked asset output in the funding transaction.
  uint32 asset_vout = 8;

  // The vout of the locked LBTC output in the funding transaction.
  uint32 lbtc_vout = 9;

  // The minimum required confirmations for the funding transaction.
  uint32 min_funding_confs = 10;
}

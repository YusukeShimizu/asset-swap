---
title: LN⇄Liquid Swap (gRPC)
description: Bidirectional swap between Lightning and a Liquid HTLC.
---

This repository includes a minimal LN⇄Liquid swap implementation over gRPC.
It combines Lightning payments (BOLT11) and a Liquid HTLC (P2WSH) in two directions.

This page is the API-oriented overview.
For a regtest runbook (including issuing an asset as RWA and selling it), see
[Issue and sell an RWA (regtest)](/swap/rwa-issuance-and-sale).

## What This API Does

- `LN_TO_LIQUID` (submarine swap):
  - Seller funds a Liquid HTLC output with the asset and an LBTC fee subsidy.
  - Seller returns a BOLT11 invoice whose payment hash matches the HTLC hashlock.
  - Buyer pays the invoice, obtains the preimage, and spends the HTLC to claim the asset.
- `LIQUID_TO_LN` (reverse submarine swap):
  - Buyer funds a Liquid HTLC output with the asset and an LBTC fee subsidy.
  - Buyer returns a BOLT11 invoice whose payment hash matches the HTLC hashlock.
  - Seller pays the invoice, obtains the preimage, and spends the HTLC to claim the asset.

This is a minimal design and is not production-ready.

## Assumptions (Read First)

- The external API is **gRPC only** (no HTTP JSON).
- gRPC runs in **plaintext** by default.
  - The API uses a bearer token (`authorization: Bearer <token>`) and MUST be protected by TLS or a private network boundary.
  - Do not expose the service to the public internet.
- This minimal server uses a single LN node for both invoice creation and payment.
  - Depending on the LN backend, paying your own invoice may not be supported.
- HTLC outputs are **explicit (unblinded)** for simplicity.
- Current binaries are fixed to `ElementsNetwork::default_regtest()` (Liquid regtest).
  - Mainnet/testnet support is out of scope for this repo’s current state.

## Roles

- **Swap server**
  - Runs the gRPC server (`swap_server`).
  - Models both seller-side and buyer-side actions in a single Protobuf service.
  - Uses a single LN node and a single Liquid wallet (seller/buyer keys are separated by key index) in this minimal regtest-oriented setup.
- **CLI user**
  - Uses the CLI (`swap_cli`) or calls the gRPC API directly.

## Pricing Model (Simplest)

- The seller decides the price by configuration (`--price-msat-per-asset-unit`).
- The seller creates a quote via `CreateQuote` and shares `quote_id` with the buyer.
  - The server computes `total_price_msat = asset_amount * price_msat_per_asset_unit`.
- The buyer creates a swap via `CreateSwap(quote_id)`.
  - The server rejects if the current offer differs from the quoted offer (`offer_id` mismatch).
- The Lightning payer MUST verify the invoice amount equals `Quote.total_price_msat` before paying.
  - For `LIQUID_TO_LN`, the buyer creates the invoice and the seller verifies it before paying.

## Prerequisites

- A Lightning node via `ldk-server` (this repo uses its REST API internally).
- A Liquid backend reachable via Electrum (for example: liquid-enabled `electrs`).
- Seller inventory:
  - enough units of the asset being sold, and
  - enough LBTC to fund `fee_subsidy_sats` per swap.

## API Overview

The Protobuf schema is at `proto/ln_liquid_swap/v1/swap.proto`.
The Protobuf package name is `ln_liquid_swap.v1`.

### Authentication and Roles

All RPCs require an `authorization: Bearer <token>` gRPC metadata header.

- **Seller token** can call `CreateQuote`.
- **Buyer token** can call `CreateSwap`.
- Both tokens can call `GetQuote` and `GetSwap`.

For swap execution:

- `Swap.parties` indicates which role must call `CreateLightningPayment` and `CreateAssetClaim`.
- `Swap.direction` determines the `Swap.parties` mapping.

### `CreateQuote`

Creates a quote (pricing snapshot) for a potential swap.

The client sends a `CreateQuoteRequest`:

- `direction`: `LN_TO_LIQUID` or `LIQUID_TO_LN`.
- `asset_id`: 32-byte asset id, hex-encoded (64 hex chars).
- `asset_amount`: amount of the asset to receive (must be > 0).
- `min_funding_confs`: required confirmations for the funding transaction (0–6).

The server returns a `Quote` containing:

- `quote_id`: UUID string used for `GetQuote` and `CreateSwap`.
- `offer_id`: offer snapshot id (SHA256 hex, 32 bytes).
- `total_price_msat`: total invoice amount to be paid.
- `offer`: the offer snapshot (price and policy parameters).
- `direction` and `parties`: direction and role responsibilities for this swap.

### `GetQuote`

Fetches a quote by `quote_id`.

### `CreateSwap`

The client sends a `CreateSwapRequest`:

- `quote_id`: UUID string returned by `CreateQuote`.
- `buyer_liquid_address`: buyer-controlled Liquid P2WPKH address.
  - For `LN_TO_LIQUID` (submarine swap), used as the claim key.
  - For `LIQUID_TO_LN` (reverse submarine swap), used as the refund key.
- `buyer_bolt11_invoice`: buyer-created invoice to be paid by the seller (required for `LIQUID_TO_LN`).
  - Must be empty for `LN_TO_LIQUID`.
  - Must include an amount and must not be expired for `LIQUID_TO_LN`.

The server returns a `Swap` containing:

- `bolt11_invoice`: the Lightning invoice to pay.
- `payment_hash`: hex-encoded payment hash (must match the invoice and the HTLC witness script).
- `direction` and `parties`: direction and role responsibilities for this swap.
- `liquid`: HTLC details:
  - `witness_script` (bytes),
  - `p2wsh_address`,
  - `funding_txid`, `asset_vout`, `lbtc_vout`,
  - `refund_lock_height`.

Error handling notes:

- `INVALID_ARGUMENT` for malformed requests or validation failures.
- `INVALID_ARGUMENT` if `buyer_bolt11_invoice` is amountless, expired, or mismatched with `Quote.total_price_msat`.
- `NOT_FOUND` if the quote does not exist.
- `FAILED_PRECONDITION` when the offer changed since quoting, or when the seller cannot fund (inventory/LBTC insufficient).
- `INTERNAL` for unexpected wallet/backend failures.

### `CreateLightningPayment`

Pays the swap invoice on Lightning.

This RPC is called by `Swap.parties.ln_payer`.

The client sends a `CreateLightningPaymentRequest`:

- `swap_id`: UUID string.
- `payment_timeout_secs`: how long to wait for the preimage (0 uses a server default).

The server returns a `LightningPayment` containing:

- `payment_id`: LN backend payment id.
- `preimage` (bytes): 32-byte preimage.

### `CreateAssetClaim`

Claims the Liquid HTLC (asset acquisition).

This RPC is called by `Swap.parties.liquid_claimer`.

The client sends a `CreateAssetClaimRequest`:

- `swap_id`: UUID string.
- `claim_fee_sats`: claim tx fee in sats (0 uses a server default).

The server returns an `AssetClaim` containing:

- `claim_txid`: Liquid txid (hex).

### `GetSwap`

Fetches a swap by `swap_id`.
The current implementation uses UUID strings for ids.

Note: The server updates swap status to `PAID` / `CLAIMED` only when `CreateLightningPayment` / `CreateAssetClaim`
are executed (there is no background watcher in this minimal design).

## Lightning Payer Safety Checklist (Must Do)

Before paying `bolt11_invoice`, the Lightning payer (`Swap.parties.ln_payer`) must verify:

- The invoice payment hash matches `payment_hash`.
- The invoice amount equals `Quote.total_price_msat`.
- The payment hash in `liquid.witness_script` matches the invoice payment hash.
- The funding transaction (`funding_txid`) pays the expected P2WSH scriptPubKey:
  - `asset_vout` locks `asset_id` and `asset_amount`.
  - `lbtc_vout` locks `fee_subsidy_sats` of LBTC.
- The funding transaction has at least `min_funding_confs` confirmations.

If you call the API directly, you must perform these checks in your client implementation.

## Calling the API with `grpcurl`

`swap.proto` imports Protovalidate and `google.api.field_behavior`.
For tools that call `protoc` directly (like `grpcurl`), this repo includes a minimal set of
dependency protos under `proto_deps/`.

Example (plaintext gRPC):

```sh
grpcurl \
  -plaintext \
  -H "authorization: Bearer $SELLER_TOKEN" \
  -import-path proto \
  -import-path proto_deps \
  -proto proto/ln_liquid_swap/v1/swap.proto \
  -d '{
    "direction": "SWAP_DIRECTION_LN_TO_LIQUID",
    "asset_id": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
    "asset_amount": 1000,
    "min_funding_confs": 1
  }' \
  127.0.0.1:50051 \
  ln_liquid_swap.v1.SwapService/CreateQuote

grpcurl \
  -plaintext \
  -H "authorization: Bearer $BUYER_TOKEN" \
  -import-path proto \
  -import-path proto_deps \
  -proto proto/ln_liquid_swap/v1/swap.proto \
  -d '{
    "quote_id": "<QUOTE_ID>",
    "buyer_liquid_address": "<BUYER_LIQUID_ADDRESS>"
  }' \
  127.0.0.1:50051 \
  ln_liquid_swap.v1.SwapService/CreateSwap

# Reverse swap (LIQUID_TO_LN): buyer supplies a BOLT11 invoice.
grpcurl \
  -plaintext \
  -H "authorization: Bearer $BUYER_TOKEN" \
  -import-path proto \
  -import-path proto_deps \
  -proto proto/ln_liquid_swap/v1/swap.proto \
  -d '{
    "quote_id": "<QUOTE_ID>",
    "buyer_liquid_address": "<BUYER_LIQUID_ADDRESS>",
    "buyer_bolt11_invoice": "<BUYER_BOLT11_INVOICE>"
  }' \
  127.0.0.1:50051 \
  ln_liquid_swap.v1.SwapService/CreateSwap

grpcurl \
  -plaintext \
  -H "authorization: Bearer $BUYER_TOKEN" \
  -import-path proto \
  -import-path proto_deps \
  -proto proto/ln_liquid_swap/v1/swap.proto \
  -d '{
    "swap_id": "<SWAP_ID>",
    "payment_timeout_secs": 60
  }' \
  127.0.0.1:50051 \
  ln_liquid_swap.v1.SwapService/CreateLightningPayment

grpcurl \
  -plaintext \
  -H "authorization: Bearer $BUYER_TOKEN" \
  -import-path proto \
  -import-path proto_deps \
  -proto proto/ln_liquid_swap/v1/swap.proto \
  -d '{
    "swap_id": "<SWAP_ID>",
    "claim_fee_sats": 500
  }' \
  127.0.0.1:50051 \
  ln_liquid_swap.v1.SwapService/CreateAssetClaim
```

Notes:

- `bytes` fields (like `witness_script`) are base64-encoded in JSON.
- `CreateSwap` may block until `min_funding_confs` are reached.

## Using the Included Binaries

This repo provides two binaries:

- gRPC server: `swap_server`
- CLI: `swap_cli`

Run them via `nix develop` so required external binaries are available.

Server example:

- `--store-path` points to a local SQLite database file used for swap persistence.

```sh
nix develop -c cargo run --bin swap_server -- \
  --listen-addr 127.0.0.1:50051 \
  --ldk-rest-addr http://127.0.0.1:3001 \
  --liquid-electrum-url tcp://127.0.0.1:50001 \
  --wallet-dir ./data/wallet \
  --store-path ./data/store.sqlite3 \
  --mnemonic "$MNEMONIC" \
  --slip77 "$SLIP77" \
  --seller-token "$SELLER_TOKEN" \
  --buyer-token "$BUYER_TOKEN" \
  --sell-asset-id "$ASSET_ID" \
  --price-msat-per-asset-unit 1000 \
  --fee-subsidy-sats 10000 \
  --refund-delta-blocks 144 \
  --invoice-expiry-secs 3600
```

CLI example:

```sh
nix develop -c cargo run --bin swap_cli -- \
  --grpc-url http://127.0.0.1:50051 \
  --auth-token "$SELLER_TOKEN" \
  create-quote \
  --direction ln-to-liquid \
  --asset-id "$ASSET_ID" \
  --asset-amount 1000 \
  --min-funding-confs 1

# In this minimal setup, use the `buyer_receive_address=...` logged by `swap_server`.
nix develop -c cargo run --bin swap_cli -- \
  --grpc-url http://127.0.0.1:50051 \
  --auth-token "$BUYER_TOKEN" \
  create-swap \
  --quote-id "<QUOTE_ID>" \
  --buyer-liquid-address "$BUYER_LIQUID_ADDRESS"

# Reverse swap: buyer supplies a BOLT11 invoice to be paid by the seller.
nix develop -c cargo run --bin swap_cli -- \
  --grpc-url http://127.0.0.1:50051 \
  --auth-token "$BUYER_TOKEN" \
  create-swap \
  --quote-id "<QUOTE_ID>" \
  --buyer-liquid-address "$BUYER_LIQUID_ADDRESS" \
  --buyer-bolt11-invoice "$BUYER_BOLT11_INVOICE"
```

## Notes and Limitations

- For `LIQUID_TO_LN`, the buyer must provide a non-expired invoice with a fixed amount.
- This implementation uses explicit (unblinded) HTLC outputs for simplicity.
- This design is not fully atomic and is intended for controlled environments (for example: regtest).
- Refund handling is best-effort and depends on the `swap_server` process being up.

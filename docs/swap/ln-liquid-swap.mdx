---
title: LN→Liquid Swap (gRPC)
description: How to create a swap, pay over Lightning, and claim a Liquid HTLC.
---

This repository includes a minimal LN→Liquid swap implementation over gRPC.
It allows a buyer to pay a Lightning invoice and (practically) atomically receive a Liquid asset
locked in a P2WSH HTLC (hashlock + CLTV).

This page is the API-oriented overview.
For a regtest runbook (including issuing an asset as RWA and selling it), see
[Issue and sell an RWA (regtest)](/swap/rwa-issuance-and-sale).

## What This API Does

- Seller funds a Liquid HTLC output with the asset and an LBTC fee subsidy.
- Seller returns a BOLT11 invoice whose payment hash matches the HTLC hashlock.
- Buyer pays the invoice, obtains the preimage, and spends the HTLC to claim the asset.

This is a minimal design and is not production-ready.

## Assumptions (Read First)

- The external API is **gRPC only** (no HTTP JSON).
- gRPC runs in **plaintext** and there is **no authentication/authorization**.
  - Do not expose the service to the public internet.
  - Protect it with network-level controls (private network / firewall) if used outside regtest.
- This minimal server uses a single LN node for both invoice creation and payment.
  - Depending on the LN backend, paying your own invoice may not be supported.
- HTLC outputs are **explicit (unblinded)** for simplicity.
- Current binaries are fixed to `ElementsNetwork::default_regtest()` (Liquid regtest).
  - Mainnet/testnet support is out of scope for this repo’s current state.

## Roles

- **Swap server**
  - Runs the gRPC server (`swap_server`).
  - Models both seller-side and buyer-side actions in a single Protobuf service.
  - Uses a single LN node and a single Liquid wallet (seller/buyer keys are separated by key index) in this minimal regtest-oriented setup.
- **CLI user**
  - Uses the CLI (`swap_cli`) or calls the gRPC API directly.

## Pricing Model (Simplest)

- The seller decides the price by configuration (`--price-msat-per-asset-unit`).
- The buyer creates a quote via `CreateQuote`.
  - The server computes `total_price_msat = asset_amount * price_msat_per_asset_unit`.
- The buyer creates a swap via `CreateSwap(quote_id)`.
  - The server rejects if the current offer differs from the quoted offer (`offer_id` mismatch).
- The buyer MUST verify the invoice amount equals `Quote.total_price_msat` before paying.

## Prerequisites

- A Lightning node via `ldk-server` (this repo uses its REST API internally).
- A Liquid backend reachable via Electrum (for example: liquid-enabled `electrs`).
- Seller inventory:
  - enough units of the asset being sold, and
  - enough LBTC to fund `fee_subsidy_sats` per swap.

## API Overview

The Protobuf schema is at `proto/ln_liquid_swap/v1/swap.proto`.
The Protobuf package name is `ln_liquid_swap.v1`.

### `CreateQuote`

Creates a quote (pricing snapshot) for a potential swap.

The client sends a `CreateQuoteRequest`:

- `asset_id`: 32-byte asset id, hex-encoded (64 hex chars).
- `asset_amount`: amount of the asset to receive (must be > 0).
- `min_funding_confs`: required confirmations for the funding transaction (0–6).

The server returns a `Quote` containing:

- `quote_id`: UUID string used for `GetQuote` and `CreateSwap`.
- `offer_id`: offer snapshot id (SHA256 hex, 32 bytes).
- `total_price_msat`: total invoice amount to be paid.
- `offer`: the offer snapshot (price and policy parameters).

### `GetQuote`

Fetches a quote by `quote_id`.

### `CreateSwap`

The client sends a `CreateSwapRequest`:

- `quote_id`: UUID string returned by `CreateQuote`.

The server returns a `Swap` containing:

- `bolt11_invoice`: the Lightning invoice to pay.
- `payment_hash`: hex-encoded payment hash (must match the invoice and the HTLC witness script).
- `liquid`: HTLC details:
  - `witness_script` (bytes),
  - `p2wsh_address`,
  - `funding_txid`, `asset_vout`, `lbtc_vout`,
  - `refund_lock_height`.

Error handling notes:

- `INVALID_ARGUMENT` for malformed requests or validation failures.
- `NOT_FOUND` if the quote does not exist.
- `FAILED_PRECONDITION` when the offer changed since quoting, or when the seller cannot fund (inventory/LBTC insufficient).
- `INTERNAL` for unexpected wallet/backend failures.

### `CreateLightningPayment`

Pays the swap invoice on Lightning.

The client sends a `CreateLightningPaymentRequest`:

- `swap_id`: UUID string.
- `payment_timeout_secs`: how long to wait for the preimage (0 uses a server default).

The server returns a `LightningPayment` containing:

- `payment_id`: LN backend payment id.
- `preimage` (bytes): 32-byte preimage.

### `CreateAssetClaim`

Claims the Liquid HTLC (asset acquisition).

The client sends a `CreateAssetClaimRequest`:

- `swap_id`: UUID string.
- `claim_fee_sats`: claim tx fee in sats (0 uses a server default).

The server returns an `AssetClaim` containing:

- `claim_txid`: Liquid txid (hex).

### `GetSwap`

Fetches a swap by `swap_id`.
The current implementation uses UUID strings for ids.

Note: The server updates swap status to `PAID` / `CLAIMED` only when `CreateLightningPayment` / `CreateAssetClaim`
are executed (there is no background watcher in this minimal design).

## Buyer Safety Checklist (Must Do)

Before paying `bolt11_invoice`, a buyer must verify:

- The invoice payment hash matches `payment_hash`.
- The invoice amount equals `Quote.total_price_msat`.
- The payment hash in `liquid.witness_script` matches the invoice payment hash.
- The funding transaction (`funding_txid`) pays the expected P2WSH scriptPubKey:
  - `asset_vout` locks `asset_id` and `asset_amount`.
  - `lbtc_vout` locks `fee_subsidy_sats` of LBTC.
- The funding transaction has at least `min_funding_confs` confirmations.

If you call the API directly, you must perform these checks in your client implementation.

## Calling the API with `grpcurl`

`swap.proto` imports Protovalidate and `google.api.field_behavior`.
For tools that call `protoc` directly (like `grpcurl`), this repo includes a minimal set of
dependency protos under `proto_deps/`.

Example (plaintext gRPC):

```sh
grpcurl \
  -plaintext \
  -import-path proto \
  -import-path proto_deps \
  -proto proto/ln_liquid_swap/v1/swap.proto \
  -d '{
    "asset_id": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
    "asset_amount": 1000,
    "min_funding_confs": 1
  }' \
  127.0.0.1:50051 \
  ln_liquid_swap.v1.SwapService/CreateQuote

grpcurl \
  -plaintext \
  -import-path proto \
  -import-path proto_deps \
  -proto proto/ln_liquid_swap/v1/swap.proto \
  -d '{
    "quote_id": "<QUOTE_ID>"
  }' \
  127.0.0.1:50051 \
  ln_liquid_swap.v1.SwapService/CreateSwap

grpcurl \
  -plaintext \
  -import-path proto \
  -import-path proto_deps \
  -proto proto/ln_liquid_swap/v1/swap.proto \
  -d '{
    "swap_id": "<SWAP_ID>",
    "payment_timeout_secs": 60
  }' \
  127.0.0.1:50051 \
  ln_liquid_swap.v1.SwapService/CreateLightningPayment

grpcurl \
  -plaintext \
  -import-path proto \
  -import-path proto_deps \
  -proto proto/ln_liquid_swap/v1/swap.proto \
  -d '{
    "swap_id": "<SWAP_ID>",
    "claim_fee_sats": 500
  }' \
  127.0.0.1:50051 \
  ln_liquid_swap.v1.SwapService/CreateAssetClaim
```

Notes:

- `bytes` fields (like `witness_script`) are base64-encoded in JSON.
- `CreateSwap` may block until `min_funding_confs` are reached.

## Using the Included Binaries

This repo provides two binaries:

- gRPC server: `swap_server`
- CLI: `swap_cli`

Run them via `nix develop` so required external binaries are available.

Server example:

- `--store-path` points to a local SQLite database file used for swap persistence.

```sh
nix develop -c cargo run --bin swap_server -- \
  --listen-addr 127.0.0.1:50051 \
  --ldk-rest-addr http://127.0.0.1:3001 \
  --liquid-electrum-url tcp://127.0.0.1:50001 \
  --wallet-dir ./data/wallet \
  --store-path ./data/store.sqlite3 \
  --mnemonic "$MNEMONIC" \
  --slip77 "$SLIP77" \
  --sell-asset-id "$ASSET_ID" \
  --price-msat-per-asset-unit 1000 \
  --fee-subsidy-sats 10000 \
  --refund-delta-blocks 144 \
  --invoice-expiry-secs 3600
```

CLI example:

```sh
nix develop -c cargo run --bin swap_cli -- \
  --grpc-url http://127.0.0.1:50051 \
  create-quote \
  --asset-id "$ASSET_ID" \
  --asset-amount 1000 \
  --min-funding-confs 1
```

## Notes and Limitations

- This implementation uses explicit (unblinded) HTLC outputs for simplicity.
- This design is not fully atomic and is intended for controlled environments (for example: regtest).
- Refund handling is best-effort and depends on the `swap_server` process being up.
